---
layout: post
title:  "Cointegration and Pair trading"
categories: [jekyll, rstats]
tags: [knitr, servr, httpuv, websocket]
---



Consider the daily adjusted closing sotck prices of BHP Billiton Limited of Australia and Vale S.A. of Brazil. These are two natural resouces companies, which have the same risk exposure and it is interesting to find if there is a cointegrated relationship between them.

```{r}
bhp=read.table('d-bhp0206.txt',header=T);
vale=read.table('d-vale0206.txt',header=T);
# log close
x1=log(bhp[,9]);
x2=log(vale[,9]);

par(mfrow=c(2,1))
plot(x1,type='l');
plot(x2,type='l');
``` 

Let $x_t = (x_{1t},x_{2t})^T$ and consider ECM model $\Delta x_t = \Pi x_{t-1} + \dots$. The idea of johensen cointegration test is to find rank of $\Pi$ which determines the number of cointegration relationship. Cointegrating vectors can be obtained by factorizing $\Pi=\alpha \beta^T$ and looking at columns of $\beta$.

```{r}
require(urca)

x=cbind(x1,x2)
m=ca.jo(x,K=2,spec='transitory')
print(m@V)
```


There are two column vectors contained in $\beta$ as shown above, which are (1,-0.717784)<sup>T</sup> and  (1,2.668019)<sup>T</sup>.

Plot of `y1 = x1 - 0.717784*x2` looks like a stationary process which is mean-revert around 1.8. On the other hand, of `y2 = x1 + 2.668019*x2` exhibits a clear trend so it cannot be stationary. 

```{r}
y1 =  x %*% m@V[,1];
par(mfrow=c(2,1))
plot(y1,type = 'l')

y2 =  x %*% m@V[,2];
plot(y2,type = 'l')
```

In retrospect, one may apply pair trading strategy between two stocks by going long bhp 1 unit and short vale 0.717784 unit when `y1 is below 1.77`, and reverse the position when `y1 is above 1.83`.

```{r}
y1 =  x %*% m@V[,1];
par(mfrow=c(2,1))
plot(y1,type = 'l')
abline(h=1.83, col='red')
abline(h=1.77, col='green')
```


```{python}
import pandas as pd
import numpy as np
from numpy.linalg import inv,eig,cholesky
from math import sqrt
import matplotlib.pyplot as plt

da=pd.read_csv('d-bhp0206.txt',delim_whitespace=True)
da1=pd.read_csv('d-vale0206.txt',delim_whitespace=True)
x_t = np.log(np.matrix([da.adjclose, da1.adjclose]))
dx_t = np.diff(x_t)
Z_0t = dx_t[:,1:]  # dx_t
Z_1t = x_t[:,1:-1] # x_t-1
T = max(Z_0t.shape)
Z_2t = np.concatenate((np.ones((1,T)),dx_t[:,:-1])) # dx_t-1
M_00 = (Z_0t * Z_0t.T) / T;
M_01 = (Z_0t * Z_1t.T) / T;
M_02 = (Z_0t * Z_2t.T) / T;
M_11 = (Z_1t * Z_1t.T) / T;
M_12 = (Z_1t * Z_2t.T) / T;
M_22 = (Z_2t * Z_2t.T) / T;
M_21 = M_12.T;
M_20 = M_02.T;
M_10 = M_01.T;
S_11 = M_11 - M_12*inv(M_22)*M_21;
S_10 = M_10 - M_12*inv(M_22)*M_20;
S_00 = M_00 - M_02*inv(M_22)*M_20;
S_01 = M_01 - M_02*inv(M_22)*M_21;

L = cholesky(S_11)
v,w =  eig(inv(L)*S_10*inv(S_00)*S_01*inv(L.T));
W = inv(L.T)*w
const = W.max(axis=0)
W = np.divide(W,const)
res = W[::,1].T * x_t
plt.plot(np.asarray(res)[0])
plt.savefig("spread.png")
```

![mu](/spread.png) 
